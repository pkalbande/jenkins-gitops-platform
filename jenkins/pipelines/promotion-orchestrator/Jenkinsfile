import hudson.model.*
import hudson.plugins.promoted_builds.*

pipeline {
    agent {
        kubernetes {
            label 'jnlp-agent'
            defaultContainer 'jnlp'
        }
    }
    
    parameters {
        choice(name: 'APPLICATION', choices: ['app1-node', 'app2-python'], description: 'Select application to promote')
        string(name: 'BUILD_NUMBER', defaultValue: '', description: 'Build number from release-build-job to promote')
        string(name: 'VERSION', defaultValue: '', description: 'Version to promote (e.g., 1.0.0)')
        choice(name: 'PROMOTION_LEVEL', choices: ['Deploy-to-DEV', 'Deploy-to-QA', 'Deploy-to-STAGE', 'Deploy-to-PROD'], description: 'Select promotion level')
        text(name: 'APPROVAL_NOTES', defaultValue: '', description: 'Approval notes and justification')
    }
    
    environment {
        GIT_REPO = 'https://github.com/pkalbande/jenkins-gitops-platform.git'
        GIT_CREDENTIALS = 'github-token'
        DOCKER_REGISTRY = 'localhost:5000'
        PROMOTION_ENV_MAP = [
            'Deploy-to-DEV': 'dev',
            'Deploy-to-QA': 'qa',
            'Deploy-to-STAGE': 'stage',
            'Deploy-to-PROD': 'prod'
        ]
    }
    
    stages {
        stage('List Available Builds') {
            steps {
                script {
                    echo "=== Available Builds for Promotion ==="
                    echo "======================================"
                    
                    // List recent successful builds from release-build-job
                    try {
                        def releaseJob = Jenkins.instance.getItemByFullName('release-build-job')
                        if (releaseJob) {
                            def builds = releaseJob.getBuilds().findAll { 
                                it.result == hudson.model.Result.SUCCESS 
                            }.take(15)
                            
                            echo "\nðŸ“¦ Recent successful release builds:\n"
                            builds.each { build ->
                                def params = build.getAction(ParametersAction)
                                def app = params?.getParameter('APPLICATION')?.value
                                def version = params?.getParameter('VERSION')?.value
                                
                                // Get promotion status
                                def promotionStatus = ''
                                try {
                                    def promotedBuilds = build.getActions(hudson.plugins.promoted_builds.Status)
                                    if (promotedBuilds) {
                                        def promotions = promotedBuilds[0].getPromotionProcesses()
                                        def promotedNames = promotions.findAll { it.isMet() }.collect { it.name }
                                        if (promotedNames) {
                                            promotionStatus = " âœ“ [${promotedNames.join(', ')}]"
                                        }
                                    }
                                } catch (Exception pe) {
                                    // Promotion status not available
                                }
                                
                                if (app && version) {
                                    echo "  #${build.number} - ${app}:${version}${promotionStatus}"
                                }
                            }
                            echo "\n======================================"
                        } else {
                            echo "âš ï¸  release-build-job not found"
                        }
                    } catch (Exception e) {
                        echo "Note: Could not fetch release build history: ${e.message}"
                    }
                    
                    echo "\nðŸŽ¯ Selected for promotion:"
                    echo "  Application: ${params.APPLICATION}"
                    echo "  Build Number: ${params.BUILD_NUMBER ?: 'Will use latest'}"
                    echo "  Version: ${params.VERSION}"
                    echo "  Promotion Level: ${params.PROMOTION_LEVEL}"
                    echo "======================================"
                }
            }
        }
        
        stage('Validate Parameters') {
            steps {
                script {
                    echo "=== Validating Promotion Request ==="
                    
                    if (!params.BUILD_NUMBER) {
                        error("Build number is required. Check the list above and specify a build number.")
                    }
                    
                    if (!params.VERSION) {
                        error("Version parameter is required")
                    }
                    
                    // Get target environment from promotion level
                    def targetEnv = PROMOTION_ENV_MAP[params.PROMOTION_LEVEL]
                    if (!targetEnv) {
                        error("Invalid promotion level: ${params.PROMOTION_LEVEL}")
                    }
                    
                    env.TARGET_ENV = targetEnv
                    echo "âœ“ Target Environment: ${env.TARGET_ENV}"
                }
            }
        }
        
        stage('Verify Build Exists') {
            steps {
                script {
                    echo "Verifying build #${params.BUILD_NUMBER} exists..."
                    
                    def releaseJob = Jenkins.instance.getItemByFullName('release-build-job')
                    if (!releaseJob) {
                        error("release-build-job not found")
                    }
                    
                    def targetBuild = releaseJob.getBuildByNumber(params.BUILD_NUMBER as Integer)
                    if (!targetBuild) {
                        error("Build #${params.BUILD_NUMBER} not found")
                    }
                    
                    if (targetBuild.result != hudson.model.Result.SUCCESS) {
                        error("Build #${params.BUILD_NUMBER} did not complete successfully (${targetBuild.result})")
                    }
                    
                    // Verify version matches
                    def buildParams = targetBuild.getAction(ParametersAction)
                    def buildVersion = buildParams?.getParameter('VERSION')?.value
                    if (buildVersion != params.VERSION) {
                        error("Version mismatch: Build has ${buildVersion}, but you specified ${params.VERSION}")
                    }
                    
                    echo "âœ“ Build #${params.BUILD_NUMBER} verified (${params.APPLICATION}:${params.VERSION})"
                }
            }
        }
        
        stage('Check Promotion Prerequisites') {
            steps {
                script {
                    echo "Checking promotion prerequisites for ${params.PROMOTION_LEVEL}..."
                    
                    def releaseJob = Jenkins.instance.getItemByFullName('release-build-job')
                    def targetBuild = releaseJob.getBuildByNumber(params.BUILD_NUMBER as Integer)
                    
                    // Check if previous promotions are met
                    def requiredPromotions = [
                        'Deploy-to-DEV': [],
                        'Deploy-to-QA': ['Deploy-to-DEV'],
                        'Deploy-to-STAGE': ['Deploy-to-QA'],
                        'Deploy-to-PROD': ['Deploy-to-STAGE']
                    ]
                    
                    def required = requiredPromotions[params.PROMOTION_LEVEL]
                    if (required) {
                        echo "Checking prerequisite promotions: ${required}"
                        
                        try {
                            def promotionStatus = targetBuild.getActions(hudson.plugins.promoted_builds.Status)
                            if (promotionStatus) {
                                def promotions = promotionStatus[0].getPromotionProcesses()
                                def promotedNames = promotions.findAll { it.isMet() }.collect { it.name }
                                
                                required.each { req ->
                                    if (!promotedNames.contains(req)) {
                                        error("âŒ Prerequisite promotion not met: ${req}")
                                    }
                                    echo "âœ“ ${req} - Completed"
                                }
                            } else {
                                error("No promotion information available for this build")
                            }
                        } catch (Exception e) {
                            echo "âš ï¸  Warning: Could not verify promotion prerequisites: ${e.message}"
                        }
                    }
                    
                    echo "âœ“ All prerequisites met"
                }
            }
        }
        
        stage('Trigger Promotion') {
            steps {
                script {
                    echo "Triggering promotion: ${params.PROMOTION_LEVEL}"
                    echo "Approval Notes: ${params.APPROVAL_NOTES ?: 'None provided'}"
                    
                    def releaseJob = Jenkins.instance.getItemByFullName('release-build-job')
                    def targetBuild = releaseJob.getBuildByNumber(params.BUILD_NUMBER as Integer)
                    
                    try {
                        // Get the promotion process
                        def jobProperty = releaseJob.getProperty(JobPropertyImpl.class)
                        if (!jobProperty) {
                            error("No promotions configured for release-build-job")
                        }
                        
                        def promotionProcess = jobProperty.getItem(params.PROMOTION_LEVEL)
                        if (!promotionProcess) {
                            error("Promotion process ${params.PROMOTION_LEVEL} not found")
                        }
                        
                        // Manually approve the promotion
                        def promotionCondition = new ManualCondition()
                        promotionCondition.approve(targetBuild, promotionProcess)
                        
                        echo "âœ“ Promotion ${params.PROMOTION_LEVEL} triggered for build #${params.BUILD_NUMBER}"
                        
                        // Wait for promotion to complete
                        sleep(time: 5, unit: 'SECONDS')
                        
                    } catch (Exception e) {
                        echo "âš ï¸  Promotion trigger via API failed: ${e.message}"
                        echo "Note: Proceeding with manual deployment to ${env.TARGET_ENV}"
                    }
                }
            }
        }
        
        stage('Update Target Environment') {
            steps {
                script {
                    echo "Deploying ${params.APPLICATION}:${params.VERSION} to ${env.TARGET_ENV}"
                    
                    withCredentials([string(credentialsId: 'github-token', variable: 'GITHUB_TOKEN')]) {
                        sh """
                            # Configure git
                            git config --global user.email "jenkins@gitops.local"
                            git config --global user.name "Jenkins Promotion Bot"
                            
                            # Clone repository
                            git clone https://\${GITHUB_TOKEN}@github.com/pkalbande/jenkins-gitops-platform.git workspace
                            cd workspace
                            
                            # Checkout master branch
                            git checkout master
                            
                            # Update target environment values file
                            TARGET_VALUES="environments/${env.TARGET_ENV}/${params.APPLICATION}-values.yaml"
                            
                            # Create directory if it doesn't exist
                            mkdir -p environments/${env.TARGET_ENV}
                            
                            # Update or create values file
                            if [ -f "\${TARGET_VALUES}" ]; then
                                sed -i.bak "s/tag: .*/tag: ${params.VERSION}/" \${TARGET_VALUES}
                                rm -f \${TARGET_VALUES}.bak
                            else
                                cat > \${TARGET_VALUES} << EOF
image:
  repository: ${DOCKER_REGISTRY}/${params.APPLICATION}
  tag: ${params.VERSION}
  pullPolicy: Always

# Promoted from build #${params.BUILD_NUMBER}
# Promotion Level: ${params.PROMOTION_LEVEL}
# Date: \$(date -u +"%Y-%m-%dT%H:%M:%SZ")
EOF
                            fi
                            
                            # Commit and push changes
                            git add \${TARGET_VALUES}
                            git commit -m "ðŸš€ Promote ${params.APPLICATION}:${params.VERSION} to ${env.TARGET_ENV} [Build #${params.BUILD_NUMBER}]

Promotion: ${params.PROMOTION_LEVEL}
Source Build: #${params.BUILD_NUMBER}
Approval Notes: ${params.APPROVAL_NOTES ?: 'Automated promotion'}
"
                            git push origin master
                            
                            echo "âœ“ Successfully deployed to ${env.TARGET_ENV}"
                        """
                    }
                }
            }
        }
        
        stage('Trigger ArgoCD Sync') {
            steps {
                script {
                    echo "Triggering ArgoCD sync for ${params.APPLICATION} in ${env.TARGET_ENV}"
                    
                    sh """
                        echo "ArgoCD will automatically sync the changes"
                        echo "Application: ${params.APPLICATION}-${env.TARGET_ENV}"
                        echo "New version: ${params.VERSION}"
                        echo "Promoted via: ${params.PROMOTION_LEVEL}"
                    """
                }
            }
        }
        
        stage('Verify Deployment') {
            steps {
                script {
                    echo "Verifying deployment in ${env.TARGET_ENV}"
                    
                    sh """
                        echo "Waiting for ArgoCD to sync..."
                        sleep 10
                        
                        # Check if pods are running in target namespace
                        echo "Checking deployment status..."
                        kubectl get pods -n ${env.TARGET_ENV} -l app=${params.APPLICATION} || echo "Namespace ${env.TARGET_ENV} may not exist yet"
                        
                        echo "âœ“ Deployment verification complete"
                    """
                }
            }
        }
    }
    
    post {
        success {
            script {
                echo """
========================================
âœ“ PROMOTION SUCCESSFUL
========================================
Application: ${params.APPLICATION}
Version: ${params.VERSION}
Build Number: #${params.BUILD_NUMBER}
Promotion Level: ${params.PROMOTION_LEVEL}
Target Environment: ${env.TARGET_ENV}
Approval Notes: ${params.APPROVAL_NOTES ?: 'None'}
========================================
Next Steps:
- Monitor deployment in ${env.TARGET_ENV}
- Check application health and logs
- Run smoke tests if required
========================================
"""
            }
        }
        failure {
            script {
                echo """
========================================
âœ— PROMOTION FAILED
========================================
Application: ${params.APPLICATION}
Version: ${params.VERSION}
Build Number: #${params.BUILD_NUMBER}
Promotion Level: ${params.PROMOTION_LEVEL}
Target Environment: ${env.TARGET_ENV}
========================================
Action Required:
- Review build logs for errors
- Check prerequisites are met
- Verify build artifacts exist
========================================
"""
            }
        }
        always {
            cleanWs()
        }
    }
}
